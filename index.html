<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Semin Kim - UX 디자이너 포트폴리오</title>
  <style>
    /* 구글 웹폰트 대신 로컬 woff 파일 사용 */
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Light.woff") format("woff");
      font-weight: 300;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Epilogue";
      src: url("https://fonts.googleapis.com/css?family=Epilogue:400,600");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Light";
      src: url("woff/Pretendard-Light.woff") format("woff");
      font-weight: 300;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Regular";
      src: url("woff/Pretendard-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Bold";
      src: url("woff/Pretendard-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
    }

    :root { 
      --black: #2d2d2d;
      --black-2: #000000;
      --fern: #65c479;
      --sunset-orange: #ff6250;
      --white: #ffffff;
      --blue-light: #41d9ff;
      --blue-medium: #517fff;
      --yellow: #ffd453;
      --bg-blue: #87a0ae;
     
      --font-size-l: 20px;
      --font-size-m: 17px;
      --font-size-xl: 37px;
      --font-size-xxl: 38px;
      --font-size-xxxl: 48px;
      --font-size-xxxxl: 82px;
      --font-size-xxxxxl: 54px;
     
      --font-family-epilogue: "Epilogue", Helvetica;
      --font-family-jost: "Jost", Helvetica;
      --font-family-pretendard-light: "Pretendard-Light", Helvetica, Arial, sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family-jost);
      background-color: var(--white);
      color: var(--black);
    }

    .subtitle {
      font-family: var(--font-family-epilogue);
      font-size: var(--font-size-l);
      font-style: normal;
      font-weight: 600;
      letter-spacing: 0px;
    }

    .body-text {
      font-family: var(--font-family-epilogue);
      font-size: var(--font-size-m);
      font-style: normal;
      font-weight: 400;
      letter-spacing: 0px;
    }

    .valign-text-middle {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .container-center-horizontal {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    /* SECTION 1: Header/Navigation */
    .header {
      background-color: var(--bg-blue);
      width: 100%;
      height: 70px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 40px;
    }

    .logo {
      color: var(--white);
      font-size: var(--font-size-l);
      font-weight: 400;
    }

    .menu {
      display: flex;
      gap: 24px;
    }

    .menu-item {
      color: var(--white);
      font-size: var(--font-size-m);
      text-decoration: none;
    }

    /* SECTION 2: Hero section with blue background */
    .hero-section {
      background-color: var(--bg-blue);
      width: 100%;
      height: 100vh;
      padding: 0 40px;
      position: relative;
      /* 중앙 정렬 유지 */
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .hero-title, .hero-subtitle {
      transform: translateY(calc(-5vh - 30px));
      overflow: hidden;
    }

    .hero-title {
      color: rgba(255, 255, 255, 0.6);
      font-size: clamp(4rem, 7vw, 7rem);
      font-weight: 700;
      position: relative;
      margin-bottom: 5px;
      perspective: 1000px;
    }
    .hero-subtitle {
      color: var(--white);
      font-size: clamp(4rem, 7vw, 7rem);
      font-weight: 700;
      position: relative;
      perspective: 1000px;
    }


    .js-split-char, .js-split-word {
      display: inline-block;
      opacity: 0;
      transform: translateY(100%);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }

    .is-animated .js-split-char,
    .is-animated .js-split-word {
      opacity: 1;
      transform: translateY(0);
    }

    /* 미디어 쿼리: 모니터 크기가 클 때 글자 크기는 뷰포트 단위로 처리됨 */
    @media screen and (min-width: 1440px) {
      .hero-section {
        padding: 0 60px;
      }
    }

    /* SECTION 3: Feature boxes and main text */
    /* 섹션 3 스크롤 애니메이션을 위한 추가 CSS */
    .section-features {
      position: relative;
      padding-top: 120px;
      padding-bottom: 120px;
      overflow: hidden;
    }

    .features-container {
      position: relative;
      width: 100%;
      max-width: 1200px;
      height: 600px; /* 충분한 높이 확보 */
      margin: 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .features-section {
      position: relative;
      z-index: 2;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .feature-box {
      position: absolute; /* 절대 위치로 설정해 원형 배치 가능하게 함 */
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      text-align: center;
      padding: 15px;
      will-change: transform, width, height;
      transform-origin: center center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border-radius: 40px;
      z-index: 3;
      transition: all 0.5s ease-out;
    }

    .feature-service {
      background-color: var(--sunset-orange);
    }

    .feature-usefulness {
      background-color: var(--blue-medium);
    }

    .feature-empathy {
      background-color: var(--fern);
    }

    .main-text-container {
      position: absolute;
      width: 100%;
      text-align: center;
      z-index: 1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      overflow: hidden;
      /* 최대 높이 2줄로 제한 */
      max-height: calc(var(--font-size-xxxxxl) * 1.4 * 2);
      line-height: 1.4;
    }

    .main-text {
      font-family: var(--font-family-pretendard-light);
      font-size: var(--font-size-xxxxxl);
      font-weight: 300;
      color: #869298;
      text-align: center;
      line-height: 1.4;
      margin: 0;
      position: relative;
      z-index: 1;
      will-change: font-size, opacity;
      transition: font-size 0.5s ease-out, opacity 0.5s ease-out;
      /* 글자가 항상 2줄로만 보이도록 */
      white-space: nowrap;
    }

    .feature-readability {
      position: absolute;
      background-color: var(--blue-light);
      border-radius: 40px;
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      will-change: transform, width, height;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      transform-origin: center center;
      z-index: 3;
      transition: all 0.5s ease-out;
    }

    .clarity-box {
      position: absolute;
      background-color: var(--yellow);
      border-radius: 40px;
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      will-change: transform, width, height;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      transform-origin: center center;
      z-index: 3;
      transition: all 0.5s ease-out;
    }

    /* 호버 효과 추가 */
    .feature-box:hover, .feature-readability:hover, .clarity-box:hover {
      transform: scale(1.05) translate(0px, 0px) !important;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease-out !important;
      z-index: 10;
    }

    /* SECTION 3-2: UX Sections (Consulting, Planning, GUI) */
    .ux-sections {
      width: 100%;
      max-width: 800px;
      margin: 50px auto;
    }

    .ux-consulting {
      font-size: var(--font-size-xxxl);
      color: var(--fern);
      text-align: center;
      margin-bottom: 40px;
    }

    .ux-planning {
      font-size: var(--font-size-xxxl);
      color: var(--blue-medium);
      text-align: center;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ux-gui {
      font-size: var(--font-size-xxxl);
      color: var(--sunset-orange);
      text-align: center;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon {
      width: 24px;
      height: 24px;
      margin-right: 10px;
    }

    /* SECTION 4: Works section */
    .works-section {
      width: 100%;
      max-width: 1200px;
      margin: 50px auto;
      padding: 0 20px;
    }

    .works-title {
      font-size: 32px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 40px;
    }

    .works-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
    }

    .work-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .work-image {
      width: 100%;
      height: 250px;
      background-color: #f5f5f5;
      border-radius: 8px;
    }

    .work-title {
      font-weight: 600;
      font-size: 20px;
    }

    .work-description {
      font-size: 17px;
      color: var(--black);
    }


    /* 고밀도 화면(레티나 등)에서는 글자 크기 줄이기 */
    @media screen and (min-resolution: 2dppx) {
      .hero-title, .hero-subtitle {
        font-size: clamp(4rem, 6vw, 6rem);
      }
    }


    /* 반응형: 작은 화면에서 작업 그리드 조정 */
    @media screen and (max-width: 768px) {
      .works-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media screen and (max-width: 480px) {
      .works-grid {
        grid-template-columns: 1fr;
      }
    }

    @media only screen and (min-width: 2000px) {
      .section-features {
        --padding-x: 1vw;
        --padding-y: 1vw;
        font-size: .8vw;
      }
    }
  </style>
</head>
<body>
  <div class="container-center-horizontal">
    <!-- SECTION 1: Header/Navigation -->
    <header class="header">
      <div class="logo">Semin Kim</div>
      <nav class="menu">
        <a href="#" class="menu-item">About</a>
        <a href="#" class="menu-item">UX Works</a>
        <a href="#" class="menu-item">Contact</a>
      </nav>
    </header>
    
    <!-- SECTION 2: Hero section with blue background -->
    <section class="hero-section">
      <div class="hero-text-container">
        <h2 class="hero-title">I Design</h2>
        <h1 class="hero-subtitle">Inside & Outside of Service</h1>
      </div>
    </section>
    
    <!-- SECTION 3: Feature boxes and main text -->
    <section class="section-features">
      <div class="features-container">
        <!-- Feature boxes -->
        <div class="feature-box feature-service">
          <span>Service Purpose</span>
        </div>
        <div class="feature-box feature-usefulness">
          <span>Sense of Usefulness</span>
        </div>
        <div class="feature-box feature-empathy">
          <span>Empathy</span>
        </div>
        
        <!-- Additional feature box -->
        <div class="feature-readability">
          <span>Readability</span>
        </div>
        
        <!-- Clarity box -->
        <div class="clarity-box">
          <span>Clarity</span>
        </div>
        
        <!-- Main text -->
        <div class="main-text-container">
          <h1 class="main-text">서비스와 사용자를 연구하여<br>UX를 디자인합니다.</h1>
        </div>
      </div>
    </section>
    
    <!-- SECTION 3-2: UX Sections (Consulting, Planning, GUI) -->
    <section class="ux-sections">
      <div class="ux-consulting">
        <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="#65c479" stroke-width="2"/>
          <path d="M8 12L11 15L16 9" stroke="#65c479" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        UX Consulting
      </div>
      
      <div class="ux-planning">
        <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 4H20V20H4V4Z" stroke="#517fff" stroke-width="2"/>
          <path d="M4 8H20" stroke="#517fff" stroke-width="2"/>
          <path d="M8 8V20" stroke="#517fff" stroke-width="2"/>
        </svg>
        Planning & Wireframe
      </div>
      
      <div class="ux-gui">
        <svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3 7.8C3 6.2536 4.2536 5 5.8 5H18.2C19.7464 5 21 6.2536 21 7.8V16.2C21 17.7464 19.7464 19 18.2 19H5.8C4.2536 19 3 17.7464 3 16.2V7.8Z" stroke="#ff6250" stroke-width="2"/>
          <path d="M7 10L17 10" stroke="#ff6250" stroke-width="2"/>
          <path d="M7 14L14 14" stroke="#ff6250" stroke-width="2"/>
        </svg>
        GUI & Interaction
      </div>
    </section>
    
    <!-- SECTION 4: Works section -->
    <section class="works-section">
      <h2 class="works-title">Works</h2>
      <div class="works-grid">
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
        <article class="work-card">
          <div class="work-image"></div>
          <div class="work-title">Project title</div>
          <div class="work-description">UI, Art direction</div>
        </article>
      </div>
    </section>
  </div>

<script>
// Text splitting and animation class
class TextSplitter {
  constructor(options = {}) {
    this.elements = Array.isArray(options.elements) ? options.elements : [options.elements];
    this.type = options.type || 'chars'; // chars, words
    this.delay = options.delay || 0;
    this.charDelay = options.charDelay || 0.05;
    this.wordDelay = options.wordDelay || 0.1;
    
    this.init();
  }
  
  init() {
    this.elements.forEach(element => {
      if (!element) return;
      
      // Store original text
      const originalText = element.textContent;
      element.dataset.originalText = originalText;
      
      // Clear element
      element.innerHTML = '';
      
      if (this.type === 'chars') {
        // 글자별로 분리 시 공백 처리 개선
        const chars = Array.from(originalText); // split('')보다 더 정확하게 공백 보존
        
        chars.forEach((char, index) => {
          if (char === ' ') {
            // 공백은 일반 텍스트 노드로 추가
            element.appendChild(document.createTextNode(' '));
          } else {
            const span = document.createElement('span');
            span.classList.add('js-split-char');
            span.textContent = char;
            span.style.transitionDelay = `${this.delay + (index * this.charDelay)}s`;
            element.appendChild(span);
          }
        });
      } else {
        // Split by words
        const words = originalText.split(' ');
        
        words.forEach((word, index) => {
          const span = document.createElement('span');
          span.classList.add('js-split-word');
          span.textContent = word;
          span.style.transitionDelay = `${this.delay + (index * this.wordDelay)}s`;
          element.appendChild(span);
          
          // Add space after each word except the last one
          if (index < words.length - 1) {
            element.appendChild(document.createTextNode(' '));
          }
        });
      }
      
      // Add class to indicate element is split
      element.classList.add('is-splitted');
      
      // Trigger animation after a small delay
      setTimeout(() => {
        element.classList.add('is-animated');
      }, 100);
    });
  }
}

// 텍스트 분할 애니메이션을 위한 CSS 스타일 추가
const styleElement = document.createElement('style');
styleElement.textContent = `
  .js-split-char, .js-split-word {
    display: inline-block;
    opacity: 0;
    transform: translateY(100%);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }

  .is-animated .js-split-char,
  .is-animated .js-split-word {
    opacity: 1;
    transform: translateY(0);
  }
`;
document.head.appendChild(styleElement);

// Initialize animation when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Get hero title and subtitle
  const heroTitle = document.querySelector('.hero-title');
  const heroSubtitle = document.querySelector('.hero-subtitle');
  
  // Apply text splitting to hero title
  new TextSplitter({
    elements: heroTitle,
    type: 'chars',
    delay: 0.2,
    charDelay: 0.04
  });
  
  // Apply text splitting to hero subtitle with a slight delay
  new TextSplitter({
    elements: heroSubtitle,
    type: 'chars',
    delay: 0.5, // Start after title animation has begun
    charDelay: 0.03
  });

  // 섹션 3 스크롤 애니메이션을 위한 요소 선택
  const featureBoxes = document.querySelectorAll('.feature-box');
  const mainText = document.querySelector('.main-text');
  const featureReadability = document.querySelector('.feature-readability');
  const clarityBox = document.querySelector('.clarity-box');
  const featuresContainer = document.querySelector('.features-container');
  
  // 메인 텍스트 초기 설정 (300% 크기로 시작)
  if (mainText) {
    const originalFontSize = parseFloat(getComputedStyle(mainText).fontSize);
    const initialSize = originalFontSize * 3; // 300%
    const finalSize = originalFontSize * 1.8; // 180%
    
    mainText.dataset.originalFontSize = originalFontSize;
    mainText.dataset.initialSize = initialSize;
    mainText.dataset.finalSize = finalSize;
    
    // 초기 크기 설정
    mainText.style.fontSize = `${initialSize}px`;
    mainText.style.opacity = '0.7'; // 시작 시 약간 흐릿하게
  }
  
  // 박스들 초기 위치와 크기 설정 - 밖으로 넓게 퍼져있는 상태로 시작
  const allBoxes = [
    ...Array.from(featureBoxes), 
    featureReadability, 
    clarityBox
  ].filter(box => box); // null 제거
  
  // 화면 중앙 계산
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const centerScreenX = viewportWidth / 2;
  const centerScreenY = viewportHeight / 2;
  
  allBoxes.forEach((box, index) => {
    if (!box) return;
    
    // 원래 크기와 위치 저장
    const originalWidth = 150;
    const originalHeight = 150;
    box.dataset.originalWidth = originalWidth;
    box.dataset.originalHeight = originalHeight;
    
    // 크기를 200% 로 시작
    const scaleFactor = 2;
    const initialWidth = originalWidth * scaleFactor;
    const initialHeight = originalHeight * scaleFactor;
    
    box.style.width = `${initialWidth}px`;
    box.style.height = `${initialHeight}px`;
    box.style.transition = 'all 0.5s ease-out';
    
    // 초기 위치 설정 - 각 박스마다 다른 위치로 밖으로 배치
    // 원형으로 배치되는 효과를 주기 위한 각도 계산 (5개 아이템)
    const totalBoxes = 5;
    const angle = (2 * Math.PI / totalBoxes) * index;
    const radius = Math.min(viewportWidth, viewportHeight) * 0.4; // 원의 반지름 (퍼짐 정도) - 화면 크기에 비례
    
    // 화면 중앙을 기준으로 위치 계산
    const containerRect = featuresContainer.getBoundingClientRect();
    const containerCenterX = containerRect.left + containerRect.width / 2;
    const containerCenterY = containerRect.top + containerRect.height / 2;
    
    // 각도에 따른 xy 좌표 계산 (극좌표계 -> 직교좌표계)
    const translateX = radius * Math.cos(angle);
    const translateY = radius * Math.sin(angle);
    
    // 최종 위치 (화면 중앙을 기준으로 계산)
    const finalCenterX = containerCenterX - originalWidth * 1.5 / 2; // 150% 크기일 때 중앙
    const finalCenterY = containerCenterY - originalHeight * 1.5 / 2; // 150% 크기일 때 중앙
    
    // 초기 위치 (화면 중앙에서 radius만큼 떨어진 위치)
    const initialX = finalCenterX + translateX;
    const initialY = finalCenterY + translateY;
    
    box.dataset.initialX = initialX;
    box.dataset.initialY = initialY;
    box.dataset.finalX = finalCenterX;
    box.dataset.finalY = finalCenterY;
    
    box.style.left = `${initialX}px`;
    box.style.top = `${initialY}px`;
  });

  // 스크롤 이벤트 리스너 추가
  window.addEventListener('scroll', () => {
    // 섹션의 위치와 높이 가져오기
    const section = document.querySelector('.section-features');
    if (!section) return;
    
    const sectionTop = section.getBoundingClientRect().top;
    const sectionHeight = section.offsetHeight;
    const windowHeight = window.innerHeight;
    
    // 섹션이 뷰포트에 들어왔는지 확인
    if (sectionTop < windowHeight && sectionTop > -sectionHeight) {
  // 스크롤 진행률 계산 (0 ~ 1)
      let scrollProgress = 1 - (sectionTop / windowHeight);
      scrollProgress = Math.min(Math.max(scrollProgress, 0), 1);
      
      // 메인 텍스트 크기 조절
      if (mainText) {
        const initialSize = parseFloat(mainText.dataset.initialSize);
        const finalSize = parseFloat(mainText.dataset.finalSize);
        const newSize = initialSize - (scrollProgress * (initialSize - finalSize));
        
        mainText.style.fontSize = `${newSize}px`;
        
   // 스크롤 진행에 따라 텍스트를 더 선명하게 보이도록 함
mainText.style.opacity = 0.7 + (scrollProgress * 0.3);
      
      // 각 박스들의 크기와 위치 조절
      allBoxes.forEach(box => {
        if (!box) return;
        
        // 원래 크기의 200%에서 150%로 축소
        const originalWidth = parseFloat(box.dataset.originalWidth || 150);
        const originalHeight = parseFloat(box.dataset.originalHeight || 150);
        const initialWidth = originalWidth * 2; // 200%
        const initialHeight = originalHeight * 2; // 200%
        const finalWidth = originalWidth * 1.5; // 150% 
        const finalHeight = originalHeight * 1.5; // 150%
        
        const newWidth = initialWidth - (scrollProgress * (initialWidth - finalWidth));
        const newHeight = initialHeight - (scrollProgress * (initialHeight - finalHeight));
        
        box.style.width = `${newWidth}px`;
        box.style.height = `${newHeight}px`;
        
        // 외곽에서 중앙으로 모이는 효과
        const initialX = parseFloat(box.dataset.initialX || 0);
        const initialY = parseFloat(box.dataset.initialY || 0);
        const finalX = parseFloat(box.dataset.finalX || 0);
        const finalY = parseFloat(box.dataset.finalY || 0);
        
        // 스크롤에 따라 중앙으로 이동
        const currentX = initialX + (finalX - initialX) * scrollProgress;
        const currentY = initialY + (finalY - initialY) * scrollProgress;
        
        box.style.left = `${currentX}px`;
        box.style.top = `${currentY}px`;
      });
    }
  });
  
  // 페이지 로드 시 한 번 스크롤 이벤트 강제 호출
  window.dispatchEvent(new Event('scroll'));
  
  // 윈도우 리사이즈 이벤트 처리 - 반응형으로 중앙 위치 재계산
  window.addEventListener('resize', () => {
    // 화면 중앙 재계산
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    const containerRect = featuresContainer.getBoundingClientRect();
    const containerCenterX = containerRect.left + containerRect.width / 2;
    const containerCenterY = containerRect.top + containerRect.height / 2;
    
    allBoxes.forEach((box, index) => {
      if (!box) return;
      
      const originalWidth = parseFloat(box.dataset.originalWidth || 150);
      const originalHeight = parseFloat(box.dataset.originalHeight || 150);
      
      // 최종 위치 재계산 (항상 화면 중앙)
      const finalCenterX = containerCenterX - originalWidth * 1.5 / 2;
      const finalCenterY = containerCenterY - originalHeight * 1.5 / 2;
      
      // 각도 및 반지름 계산
      const totalBoxes = 5;
      const angle = (2 * Math.PI / totalBoxes) * index;
      const radius = Math.min(viewportWidth, viewportHeight) * 0.4;
      
      // 초기 위치 재계산
      const translateX = radius * Math.cos(angle);
      const translateY = radius * Math.sin(angle);
      
      const initialX = finalCenterX + translateX;
      const initialY = finalCenterY + translateY;
      
      // 데이터셋 업데이트
      box.dataset.initialX = initialX;
      box.dataset.initialY = initialY;
      box.dataset.finalX = finalCenterX;
      box.dataset.finalY = finalCenterY;
      
      // 스크롤 이벤트 강제 호출하여 현재 위치 업데이트
      window.dispatchEvent(new Event('scroll'));
    });
  });
});

// Apply animation on page transitions as well (for Barba.js)
if (typeof barba !== 'undefined') {
  barba.hooks.after((data) => {
    const newHeroTitle = data.next.container.querySelector('.hero-title');
    const newHeroSubtitle = data.next.container.querySelector('.hero-subtitle');
    
    if (newHeroTitle) {
      new TextSplitter({
        elements: newHeroTitle,
        type: 'chars',
        delay: 0.2,
        charDelay: 0.04
      });
    }
    
    if (newHeroSubtitle) {
      new TextSplitter({
        elements: newHeroSubtitle,
        type: 'chars',
        delay: 0.5,
        charDelay: 0.03
      });
    }
  });
}
</script>
</body>
</html>
