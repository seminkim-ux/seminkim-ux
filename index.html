<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Semin Kim - UX 디자이너 포트폴리오</title>
  <style>
    /* 구글 웹폰트 대신 로컬 woff 파일 사용 */
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Jost";
      src: url("woff/Jost-Light.woff") format("woff");
      font-weight: 300;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Epilogue";
      src: url("https://fonts.googleapis.com/css?family=Epilogue:400,600");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Light";
      src: url("woff/Pretendard-Light.woff") format("woff");
      font-weight: 300;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Regular";
      src: url("woff/Pretendard-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
    }
    
    @font-face {
      font-family: "Pretendard-Bold";
      src: url("woff/Pretendard-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
    }

    :root { 
      --black: #2d2d2d;
      --black-2: #000000;
      --fern: #65c479;
      --sunset-orange: #ff6250;
      --white: #ffffff;
      --blue-light: #41d9ff;
      --blue-medium: #517fff;
      --yellow: #ffd453;
      --bg-blue: #87a0ae;
     
      --font-size-l: 20px;
      --font-size-m: 17px;
      --font-size-xl: 37px;
      --font-size-xxl: 38px;
      --font-size-xxxl: 48px;
      --font-size-xxxxl: 82px;
      --font-size-xxxxxl: 54px;
     
      --font-family-epilogue: "Epilogue", Helvetica;
      --font-family-jost: "Jost", Helvetica;
      --font-family-pretendard-light: "Pretendard-Light", Helvetica, Arial, sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family-jost);
      background-color: var(--white);
      color: var(--black);
    }

    .subtitle {
      font-family: var(--font-family-epilogue);
      font-size: var(--font-size-l);
      font-style: normal;
      font-weight: 600;
      letter-spacing: 0px;
    }

    .body-text {
      font-family: var(--font-family-epilogue);
      font-size: var(--font-size-m);
      font-style: normal;
      font-weight: 400;
      letter-spacing: 0px;
    }

    .valign-text-middle {
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .container-center-horizontal {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    /* SECTION 1: Header/Navigation */
    .header {
      background-color: var(--bg-blue);
      width: 100%;
      height: 70px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 40px;
    }

    .logo {
      color: var(--white);
      font-size: var(--font-size-l);
      font-weight: 400;
    }

    .menu {
      display: flex;
      gap: 24px;
    }

    .menu-item {
      color: var(--white);
      font-size: var(--font-size-m);
      text-decoration: none;
    }

    /* SECTION 2: Hero section with blue background */
.hero-section {
  background-color: var(--bg-blue);
  width: 100%;
  height: 100vh;
  padding: 0 40px;
  position: relative;
  /* 중앙 정렬 유지 */
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.hero-title, .hero-subtitle {
  transform: translateY(calc(-5vh - 30px));
    overflow: hidden;
}

 .hero-title {
  color: rgba(255, 255, 255, 0.6);
  font-size: clamp(4rem, 7vw, 7rem);
  font-weight: 700;
  position: relative;
  margin-bottom: 5px;
     perspective: 1000px;
}
 .hero-subtitle {
  color: var(--white);
  font-size: clamp(4rem, 7vw, 7rem);
  font-weight: 700;
  position: relative;
     perspective: 1000px;
}


.js-split-char, .js-split-word {
  display: inline-block;
  opacity: 0;
  transform: translateY(100%);
  transition: opacity 0.6s ease, transform 0.6s ease;
}

.is-animated .js-split-char,
.is-animated .js-split-word {
  opacity: 1;
  transform: translateY(0);
}

    /* 미디어 쿼리: 모니터 크기가 클 때 글자 크기는 뷰포트 단위로 처리됨 */
    @media screen and (min-width: 1440px) {
      .hero-section {
        padding: 0 60px;
      }
    }

    /* SECTION 3: Feature boxes and main text */
    .features-section {
      width: 100%;
      display: flex;
      justify-content: space-around;
      margin-top: -80px;
      padding: 0 20px;
    }

    .feature-box {
      border-radius: 40px;
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      text-align: center;
      padding: 15px;
    }

    .feature-service {
      background-color: var(--sunset-orange);
    }

    .feature-usefulness {
      background-color: var(--blue-medium);
    }

    .feature-empathy {
      background-color: var(--fern);
    }

    .main-text {
      font-family: var(--font-family-pretendard-light);
      font-size: var(--font-size-xxxxxl);
      font-weight: 300;
      color: #869298;
      text-align: center;
      margin: 100px 0;
      line-height: 1.4;
    }

    .feature-readability {
      background-color: var(--blue-light);
      border-radius: 40px;
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      margin: 50px 0;
    }

    /* SECTION 3-2: UX Sections (Consulting, Planning, GUI) */
    .ux-sections {
      width: 100%;
      max-width: 800px;
      margin: 50px auto;
    }

    .ux-consulting {
      font-size: var(--font-size-xxxl);
      color: var(--fern);
      text-align: center;
      margin-bottom: 40px;
    }

    .ux-planning {
      font-size: var(--font-size-xxxl);
      color: var(--blue-medium);
      text-align: center;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ux-gui {
      font-size: var(--font-size-xxxl);
      color: var(--sunset-orange);
      text-align: center;
      margin-bottom: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon {
      width: 24px;
      height: 24px;
      margin-right: 10px;
    }

    .clarity-box {
      background-color: var(--yellow);
      border-radius: 40px;
      width: 150px;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--white);
      font-weight: 700;
      margin: 50px 0;
    }

    /* SECTION 4: Works section */
    .works-section {
      width: 100%;
      max-width: 1200px;
      margin: 50px auto;
      padding: 0 20px;
    }

    .works-title {
      font-size: 32px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 40px;
    }

    .works-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
    }

    .work-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .work-image {
      width: 100%;
      height: 250px;
      background-color: #f5f5f5;
      border-radius: 8px;
    }

    .work-title {
      font-weight: 600;
      font-size: 20px;
    }

    .work-description {
      font-size: 17px;
      color: var(--black);
    }


    /* 고밀도 화면(레티나 등)에서는 글자 크기 줄이기 */
@media screen and (min-resolution: 2dppx) {
  .hero-title, .hero-subtitle {
    font-size: clamp(4rem, 6vw, 6rem);
  }
}

    /* 반응형: 작은 화면에서 작업 그리드 조정 */
    @media screen and (max-width: 768px) {
      .works-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media screen and (max-width: 480px) {
      .works-grid {
        grid-template-columns: 1fr;
      }
    }

/* 섹션 3 스크롤 애니메이션을 위한 추가 CSS */
.section-features {
  position: relative;
  padding-top: 120px;
  padding-bottom: 120px;
  overflow: hidden;
}

.features-section {
  position: relative;
  z-index: 2;
  will-change: transform;
}

.feature-box {
  position: relative;
  will-change: transform, width, height;
  transform-origin: center center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  border-radius: 40px; /* 초기값 저장 */
}

.feature-readability {
  position: relative;
  will-change: transform, width, height;
  margin: 50px auto;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  transform-origin: center center;
}

.main-text {
  position: relative;
  z-index: 1;
  will-change: font-size, opacity;
  transition: font-size 0.3s ease-out, opacity 0.3s ease-out;
}

/* 호버 효과 추가 */
.feature-box:hover, .feature-readability:hover {
  transform: scale(1.05) !important;
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15);
  transition: all 0.3s ease-out !important;
}
  </style>
</head>
<body>
 <body>
  <section class="_hero-introduction">
    <header>
      <div class="sticky-slot">
        <div class="title h-full flex place-center text-center overflow-hidden">
          <h2 class="-medium relative whitespace-pre-line">일 디자인</h2>
        </div>
        <ul class="snippets absolute inset-0">
          <li>
            <div class="snippet ~t">
              <img src="path/to/snippet1.png" alt="Snippet 1">
            </div>
          </li>
          <li>
            <div class="snippet ~t">
              <img src="path/to/snippet2.png" alt="Snippet 2">
            </div>
          </li>
          <li>
            <div class="snippet ~t">
              <img src="path/to/snippet3.png" alt="Snippet 3">
            </div>
          </li>
          <li>
            <div class="snippet ~t">
              <img src="path/to/snippet4.png" alt="Snippet 4">
            </div>
          </li>
          <li>
            <div class="snippet ~t">
              <img src="path/to/snippet5.png" alt="Snippet 5">
            </div>
          </li>
        </ul>
      </div>
    </header>
    <main>
      <ul class="taglines flex flex-col items-center title-2 no-select" style="--items: 3">
        <li style="--color: #34C771; --index: 0">
          <div class="flex gap-20 items-center">
            <div class="icon-card grid place-center br-24-12">
              <span class="_icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M12 4V20" data-mode="stroke" stroke-width="1.5" stroke-linecap="square" transform-origin="12 12"></path>
                  <path d="M20 12L4 12" data-mode="stroke" stroke-width="1.5" stroke-linecap="square" transform-origin="12 12"></path>
                </svg>
              </span>
            </div>
            <h3 class="-medium">서비스 목적</h3>
          </div>
        </li>
        <li style="--color: #477EE9; --index: 1">
          <div class="flex gap-20 items-center">
            <div class="icon-card grid place-center br-24-12">
              <span class="_icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path fill-rule="evenodd" clip-rule="evenodd" d="M6.12591 12.8938C4.17366 12.243 3.19753 11.9177 2.91364 11.414C2.66784 10.9779 2.6558 10.4479 2.88155 10.0011C3.14227 9.48501 4.10262 9.11565 6.02331 8.37692L16.6505 4.28955C18.2467 3.67561 19.0449 3.36864 19.557 3.54086C20.0019 3.69045 20.3512 4.03967 20.5008 4.48457C20.673 4.99676 20.366 5.79488 19.7521 7.39113L15.6647 18.0183C14.926 19.939 14.5566 20.8993 14.0405 21.1601C13.5937 21.3858 13.0637 21.3738 12.6276 21.128C12.1239 20.8441 11.7986 19.8679 11.1478 17.9157L9.89234 14.1493L6.12591 12.8938ZM11.3434 13.7589L13.3641 19.8212L19.079 4.96264L4.22038 10.6775L10.2827 12.6983L14.0208 8.96015L15.0815 10.0208L11.3434 13.7589Z" data-mode="fill"></path>
                </svg>
              </span>
            </div>
            <h3 class="-medium">전송</h3>
          </div>
        </li>
        <li style="--color: #FB2D54; --index: 2">
          <div class="flex gap-20 items-center">
            <div class="icon-card grid place-center br-24-12">
              <span class="_icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path fill-rule="evenodd" clip-rule="evenodd" d="M4.25 14.7502H18.9395L15.4456 19.1173L16.6169 20.0544L20.1107 15.6873C20.8965 14.7051 20.1973 13.2502 18.9395 13.2502L4.25 13.2502V14.7502Z" data-mode="fill"></path>
                  <path fill-rule="evenodd" clip-rule="evenodd" d="M19.75 9.2502H5.06047L8.55418 4.88307L7.38288 3.94602L3.88917 8.31316C3.10345 9.2953 3.80271 10.7502 5.06047 10.7502L19.75 10.7502V9.2502Z" data-mode="fill"></path>
                </svg>
              </span>
            </div>
            <h3 class="-medium">교환</h3>
          </div>
        </li>
        <li></li>
      </ul>
    </main>
  </section>

<script>
// First, add this script to your HTML file (before the closing body tag)

// Text splitting and animation class (simplified version of your provided code)
class TextSplitter {
  constructor(options = {}) {
    this.elements = Array.isArray(options.elements) ? options.elements : [options.elements];
    this.type = options.type || 'chars'; // chars, words
    this.delay = options.delay || 0;
    this.charDelay = options.charDelay || 0.05;
    this.wordDelay = options.wordDelay || 0.1;
    
    this.init();
  }
  
  init() {
    this.elements.forEach(element => {
      if (!element) return;
      
      // Store original text
      const originalText = element.textContent;
      element.dataset.originalText = originalText;
      
      // Clear element
      element.innerHTML = '';
      
      if (this.type === 'chars') {
        // 글자별로 분리 시 공백 처리 개선
        const chars = Array.from(originalText); // split('')보다 더 정확하게 공백 보존
        
        chars.forEach((char, index) => {
          if (char === ' ') {
            // 공백은 일반 텍스트 노드로 추가
            element.appendChild(document.createTextNode(' '));
          } else {
            const span = document.createElement('span');
            span.classList.add('js-split-char');
            span.textContent = char;
            span.style.transitionDelay = `${this.delay + (index * this.charDelay)}s`;
            element.appendChild(span);
          }
        });
      } else {
        // Split by words
        const words = originalText.split(' ');
        
        words.forEach((word, index) => {
          const span = document.createElement('span');
          span.classList.add('js-split-word');
          span.textContent = word;
          span.style.transitionDelay = `${this.delay + (index * this.wordDelay)}s`;
          element.appendChild(span);
          
          // Add space after each word except the last one
          if (index < words.length - 1) {
            element.appendChild(document.createTextNode(' '));
          }
        });
      }
      
      // Add class to indicate element is split
      element.classList.add('is-splitted');
      
      // Trigger animation after a small delay
      setTimeout(() => {
        element.classList.add('is-animated');
      }, 100);
    });
  }
}

// 텍스트 분할 애니메이션을 위한 CSS 스타일 추가
const styleElement = document.createElement('style');
styleElement.textContent = `
  .js-split-char, .js-split-word {
    display: inline-block;
    opacity: 0;
    transform: translateY(100%);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }

  .is-animated .js-split-char,
  .is-animated .js-split-word {
    opacity: 1;
    transform: translateY(0);
  }
`;
document.head.appendChild(styleElement);

// Initialize animation when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Get hero title and subtitle
  const heroTitle = document.querySelector('._hero-introduction header h2');
  const snippets = document.querySelectorAll('._hero-introduction .snippets li');
  
  // Apply text splitting to hero title
  new TextSplitter({
    elements: heroTitle,
    type: 'chars',
    delay: 0.2,
    charDelay: 0.04
  });

  // 스크롤 기반 애니메이션을 위한 요소 선택
  const section = document.querySelector('._hero-introduction');
  const taglines = document.querySelectorAll('._hero-introduction .taglines li');

  // 스크롤 이벤트 핸들러
  const handleScroll = () => {
    if (!section) return;

    const sectionTop = section.getBoundingClientRect().top;
    const windowHeight = window.innerHeight;
    
    // 섹션이 뷰포트에 들어왔는지 확인
    if (sectionTop < windowHeight && sectionTop > -section.offsetHeight) {
      // 스크롤 진행률 계산 (0 ~ 1)
      let scrollProgress = 1 - (sectionTop / windowHeight);
      scrollProgress = Math.min(Math.max(scrollProgress, 0), 1);

      // 스니펫 애니메이션
      snippets.forEach((snippet, index) => {
        const snippetElement = snippet.querySelector('.snippet');
        if (!snippetElement) return;

        // 각 스니펫의 초기 위치와 크기에 따라 다르게 조정
        let translateX = 0, translateY = 0;
        
        switch(index) {
          case 0: // 첫 번째 스니펫
            translateX = -6 + (scrollProgress * 6);
            translateY = -40 + (scrollProgress * 40);
            break;
          case 1: // 두 번째 스니펫
            translateX = 5 - (scrollProgress * 5);
            translateY = -2 + (scrollProgress * 2);
            break;
          case 2: // 세 번째 스니펫
            translateX = 4 - (scrollProgress * 4);
            translateY = -10 + (scrollProgress * 10);
            break;
          case 3: // 네 번째 스니펫
            // 이미 transform: translate(0)이므로 별도 조정 불필요
            break;
          case 4: // 다섯 번째 스니펫
            translateX = -6 + (scrollProgress * 6);
            translateY = -10 + (scrollProgress * 10);
            break;
        }

        snippet.style.transform = `translate(${translateX}%, ${translateY}%)`;
        
        // 선명도 조절
        snippetElement.style.opacity = 1 - scrollProgress;
      });

      // 태그라인 스크롤 효과
      taglines.forEach((tagline, index) => {
        if (index < taglines.length - 1) {
          const transformValue = `translateY(calc((var(--index) - var(--items)*0.5)*1.1em * ${1 - scrollProgress}))`;
          tagline.style.transform = transformValue;
        }
      });
    }
  };

  // 스크롤 이벤트 리스너 추가
  window.addEventListener('scroll', handleScroll);

  // 초기 한 번 호출
  handleScroll();

  // 스니펫 초기 애니메이션
  snippets.forEach((snippet, index) => {
    const snippetElement = snippet.querySelector('.snippet');
    if (!snippetElement) return;

    // 각 스니펫에 순차적인 딜레이를 적용
    setTimeout(() => {
      snippetElement.style.opacity = 1;
      snippetElement.style.transform = 'translate(0, 0)';
    }, (index + 1) * 200);
  });
});

// Apply animation on page transitions as well (for Barba.js)
if (typeof barba !== 'undefined') {
  barba.hooks.after((data) => {
    const newHeroTitle = data.next.container.querySelector('._hero-introduction header h2');
    
    if (newHeroTitle) {
      new TextSplitter({
        elements: newHeroTitle,
        type: 'chars',
        delay: 0.2,
        charDelay: 0.04
      });
    }
  });
}
</script>
</body>
</html>
